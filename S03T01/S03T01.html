<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display: flex vs. Display: grid</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>Display: Flex vs. Display: Grid</h1>

    <section>
        <h2>Características de display: flex</h2>
        <p><strong>1. Modelo de diseño unidimensional:</strong> Flexbox está diseñado para gestionar la distribución de elementos en una sola dimensión: una fila o una columna. Esto lo hace ideal para alinear y distribuir el espacio entre los elementos dentro de un contenedor.</p>

        <p><strong>2. Ejes:</strong> Los elementos flexibles se organizan a lo largo de un eje principal y un eje cruzado (transversal), lo que permite un control preciso sobre la alineación y el espacio entre los elementos.</p>
        
        <table border="1">
            <tr>
                <th>Eje principal</th>
                <td>Definido por <code>flex-direction</code>.</td>
            </tr>
            <tr>
                <th>row y row-reverse</th>
                <td>Se disponen a lo largo de la fila según la dirección de la línea.</td>
            </tr>
            <tr>
                <th>column y column-reverse</th>
                <td>Se disponen desde el borde superior de la página hasta el final, según la dirección del bloque.</td>
            </tr>
            <tr>
                <th>Eje cruzado</th>
                <td>Perpendicular al eje principal.</td>
            </tr>
        </table>

        <p><strong>3. Dirección de escritura:</strong> Flexbox no asume una dirección de escritura específica. En lugar de utilizar términos como "izquierda" o "derecha", se emplean márgenes inicial y final según el idioma y la dirección de escritura del documento.</p>

        <p><strong>4. Contenedor flex:</strong> Para crear un contenedor flex, se aplica <code>display: flex</code> o <code>inline-flex</code>. Los elementos hijos del contenedor se convierten en ítems flex, adoptando el comportamiento de Flexbox automáticamente.</p>

        <p>Algunas propiedades predeterminadas del contenedor:</p>
        <ul>
            <li>Los ítems se disponen en una fila (<code>flex-direction: row</code>).</li>
            <li>Los ítems empiezan desde el margen inicial del eje principal.</li>
            <li>No se ajustan en el eje principal, pero pueden encogerse (<code>flex-shrink</code>).</li>
            <li>Los ítems se estiran para igualar la altura del ítem más alto (<code>align-items: stretch</code>).</li>
            <li><code>flex-basis</code> se establece en auto, lo que significa que el tamaño inicial de los ítems se calcula en función de su contenido.</li>
            <li>Los ítems no se envuelven en varias líneas por defecto, pero pueden modificarse con <code>flex-wrap: wrap</code>.</li>
        </ul>

        <p><strong>5. Contenedores flex multi-línea con flex-wrap:</strong> Aunque Flexbox es un modelo unidimensional, se puede permitir que los ítems se distribuyan en varias líneas con la propiedad <code>flex-wrap</code>.</p>
        
        <table border="1">
            <tr>
                <th>flex-wrap: nowrap</th>
                <td>Los ítems intentan ajustarse en una sola línea. Si no caben, se pueden encoger o sobresalir del contenedor.</td>
            </tr>
            <tr>
                <th>flex-wrap: wrap</th>
                <td>Los ítems se distribuyen en múltiples líneas en lugar de sobresalir o comprimirse demasiado.</td>
            </tr>
        </table>

        <p><strong>6. Propiedades de los ítems flex:</strong></p>
        <ul>
            <li><code>flex-basis</code>: Define el tamaño inicial de un ítem antes de aplicar el crecimiento o la contracción. El valor predeterminado es auto.</li>
            <li><code>flex-grow</code>: Controla cuánto puede crecer un ítem para ocupar el espacio disponible en el eje principal.</li>
            <li><code>flex-shrink</code>: Controla cómo los ítems se contraen cuando no hay suficiente espacio en el contenedor. Si no se especifican valores para <code>flex-grow</code> o <code>flex-shrink</code>, los ítems mantienen su tamaño y el espacio restante queda vacío.</li>
        </ul>

        <p><strong>7. Alineación y distribución del espacio:</strong></p>
        <ul>
            <li><code>align-items:</code> Alinea los ítems a lo largo del eje cruzado.</li>
            <table border="1">
                <tr><th>stretch</th><td>Los ítems se expanden para llenar el contenedor (predeterminado).</td></tr>
                <tr><th>flex-start</th><td>Alineación al inicio del eje cruzado.</td></tr>
                <tr><th>flex-end</th><td>Alineación al final del eje cruzado.</td></tr>
                <tr><th>center</th><td>Alineación centrada en el eje cruzado.</td></tr>
            </table>
            
            <li><code>justify-content:</code> Alinea los ítems en el eje principal y distribuye el espacio sobrante.</li>
            <table border="1">
                <tr>
                    <th>flex-start</th>
                    <td>Los ítems se alinean al inicio del eje principal (predeterminado).</td>
                </tr>
                <tr>
                    <th>flex-end</th>
                    <td>Los ítems se alinean al final del eje principal.</td>
                </tr>
                <tr>
                    <th>center</th>
                    <td>Los ítems se alinean en el centro del eje principal.</td>
                </tr>
                <tr>
                    <th>space-between</th>
                    <td>Distribuye los ítems con espacios iguales entre ellos.</td>
                </tr>
                <tr>
                    <th>space-around</th>
                    <td>Agrega espacio igual alrededor de cada ítem.</td>
                </tr>
                <tr>
                    <th>space-evenly</th><td>Distribuye los ítems con espacios completamente iguales entre ellos.</td>
                </tr>
            </table>
        </ul>
    </section>

    <section>
        <h2>Características de display: grid</h2>

        <p><strong>1. Modelo de diseño bidimensional:</strong> CSS Grid permite gestionar la disposición de los elementos en dos dimensiones: filas y columnas. Esto permite crear diseños de página más complejos y estructurados..</p>
    
        <p><strong>2. Cuadrícula:</strong> Una cuadrícula está formada por líneas horizontales y verticales que se intersecan, permitiendo organizar los elementos en filas y columnas dentro de un contenedor.</p>
    
        <p><strong>3. Tamaños fijos y flexibles:</strong> Grid Layout permite definir el tamaño de las filas y columnas de manera flexible o fija.</p>
        <ul>
            <li><strong>Tamaños fijos:</strong> Se pueden usar unidades absolutas como píxeles (px) para definir el tamaño fijo de filas o columnas.</li>
            <li><strong>Tamaños flexibles:</strong> También se pueden utilizar unidades relativas como porcentaje (%) o fr (fracción) para distribuir el espacio disponible.</li>
        </ul>
    
        <p><strong>4. Posicionamiento de elementos:</strong> Los elementos pueden posicionarse con precisión dentro de la cuadrícula usando diferentes métodos:</p>
        <ul>
            <li><strong>Uso de números de línea:</strong> Los elementos se colocan entre las líneas de la cuadrícula, por ejemplo, de la línea 1 a la línea 3.</li>
            <li><strong>Áreas:</strong> Los elementos pueden ubicarse en áreas específicas definidas por nombre usando <code>grid-template-areas</code>.</li>
            <li><strong>Nombre de las líneas:</strong> Pueden usarse nombres personalizados de las líneas para especificar las posiciones.</li>
        </ul>
        
        <p><strong>5. Control de alineación:</strong> Grid Layout permite un control preciso de la alineación de los elementos dentro de sus celdas y del contenedor. Se utilizan las propiedades:</p>
        <ul>
            <li><code>justify-items:</code> Alinea los elementos a lo largo del eje horizontal.</li>
            <li><code>align-items:</code> Alinea los elementos a lo largo del eje vertical.</li>
        </ul>
    
        <p><strong>6. Espacio entre elementos:</strong> Grid Layout proporciona propiedades para controlar el espacio entre las filas y columnas de la cuadrícula:</p>
        <ul>
            <li><code>grid-gap:</code> Define el espacio entre todas las filas y columnas.</li>
            <li><code>grid-row-gap:</code> Define el espacio entre las filas.</li>
            <li><code>grid-column-gap:</code> Define el espacio entre las columnas.</li>
        </ul>
    
        <p><strong>7. Subcuadrículas:</strong> Se pueden anidar cuadrículas dentro de celdas de otras cuadrículas, creando diseños aún más complejos y flexibles.</p>
    
        <p><strong>8. Repetición de elementos:</strong> La función <code>repeat()</code> permite crear filas o columnas de manera más eficiente, sin necesidad de especificar manualmente el mismo tamaño varias veces.</p>

    </section>

    <section>
        <h2>Diferencias entre Flex y Grid</h2>
        <table border="1">
            <thead>
                <tr>
                    <th>Característica</th>
                    <th>Flex</th>
                    <th>Grid</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Dimensión</td>
                    <td>Unidimensional (maneja filas o columnas, no ambos a la vez).</td>
                    <td>Bidimensional (maneja tanto filas como columnas simultáneamente).</td>
                </tr>
                <tr>
                    <td>Flujo de contenido</td>
                    <td>Basado en el contenido; los elementos se ajustan según el espacio disponible.</td>
                    <td>Basado en una cuadrícula fija; los elementos se colocan en una estructura definida de filas y columnas.</td>
                </tr>
                <tr>
                    <td>Alineación</td>
                    <td>Controla la alineación en una sola dimensión (fila o columna) con propiedades como justify-content y align-items.</td>
                    <td>Controla la alineación en ambas dimensiones, permitiendo alineación tanto en filas como en columnas, y también superposición de elementos.</td>
                </tr>
                <tr>
                    <td>Complejidad de diseño</td>
                    <td>Ideal para diseños simples y de una sola dimensión (por ejemplo, menús o barras).</td>
                    <td>Ideal para diseños complejos con varias secciones, donde se necesita controlar tanto filas como columnas.</td>
                </tr>
                <tr>
                    <td>Posicionamiento</td>
                    <td>Los elementos se distribuyen dentro del espacio disponible, ajustándose al tamaño del contenedor.</td>
                    <td>Los elementos se colocan en una cuadrícula definida, pudiendo ocupar múltiples filas y columnas.</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Casos en los que es más conveniente utilizar uno u otro</h2>
        <table border="1">
            <thead>
                <tr>
                    <th>Caso de uso</th>
                    <th>Flex</th>
                    <th>Grid</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Diseños lineales o de una sola dimensión</td>
                    <td>Ideal para diseños en una sola fila o columna (por ejemplo, menús horizontales, barras laterales).</td>
                    <td>No es necesario; Flexbox es más eficiente para este tipo de diseño.</td>
                </tr>
                <tr>
                    <td>Distribución de elementos en una cuadrícula compleja</td>
                    <td>No es adecuado para diseños que requieren control sobre filas y columnas al mismo tiempo.</td>
                    <td>Perfecto para diseños de páginas complejas con múltiples filas y columnas (por ejemplo, diseños de rejilla para galerías, páginas web de múltiples secciones).</td>
                </tr>
                <tr>
                    <td>Control de alineación en una sola dimensión</td>
                    <td>Mejor para alinear elementos en una sola fila o columna (por ejemplo, en formularios o botones alineados horizontalmente).</td>
                    <td>No es necesario, ya que Grid tiene un control más avanzado de alineación en ambas dimensiones.</td>
                </tr>
                <tr>
                    <td>Cuando los elementos deben ocupar espacio dinámico</td>
                    <td>Ideal cuando los elementos deben ajustarse al tamaño disponible del contenedor, como en barras de navegación o cajas de contenido de tamaño variable.</td>
                    <td>Menos eficiente, ya que Grid define un espacio fijo para cada celda.</td>
                </tr>
                <tr>
                    <td>Distribución flexible de elementos dentro de un contenedor</td>
                    <td>Perfecto cuando los elementos deben cambiar su tamaño o distribución dependiendo del espacio disponible en el contenedor.</td>
                    <td>Aunque se puede usar, Grid no ofrece tanta flexibilidad para elementos con tamaño dinámico.</td>
                </tr>
                <tr>
                    <td>Diseños con superposición de elementos</td>
                    <td>No es ideal, ya que Flexbox no permite la superposición de elementos.</td>
                    <td>Permite la superposición de elementos utilizando áreas de cuadrícula o posicionamiento dentro de celdas, ideal para diseños más complejos.</td>
                </tr>
                <tr>
                    <td>Uso combinado</td>
                    <td>No se puede usar Grid dentro de un Flexbox.</td>
                    <td>En algunos contextos, se puede utilizar Flexbox dentro de las celdas de un diseño Grid para obtener un control adicional sobre el contenido dentro de las celdas.</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Ejemplos de uso</h2>

        <h3>Ejemplo de Flex</h3>
        
        <pre>
        <strong>ejemploflex.html</strong> 

        &lt;!DOCTYPE html&gt;
        &lt;html lang="es"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;Flexbox Básico&lt;/title&gt;
            &lt;link rel="stylesheet" href="estilos.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;

            &lt;div class="contenedor-flex"&gt;
                &lt;div class="elemento-flex"&gt;Elemento 1&lt;/div&gt;
                &lt;div class="elemento-flex"&gt;Elemento 2&lt;/div&gt;
                &lt;div class="elemento-flex"&gt;Elemento 3&lt;/div&gt;
            &lt;/div&gt;

        &lt;/body&gt;
        &lt;/html&gt;

        <strong>estilos.css</strong>
        
        .contenedor-flex {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .elemento-flex {
            background-color: #fd9dc9;
            color: rgb(0, 0, 0);
            text-align: center;
            padding: 20px;
            border-radius: 4px;
        }
        </pre>

        <div class="contenedor-flex">
            <div class="elemento-flex">Elemento 1</div>
            <div class="elemento-flex">Elemento 2</div>
            <div class="elemento-flex">Elemento 3</div>
        </div>

        <h3>Ejemplo de Grid</h3>
        <pre>
        
        <strong>ejemplogrid.html</strong>  

        &lt;!DOCTYPE html&gt;
        &lt;html lang="es"&gt;
        &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Grid Básico&lt;/title&gt;
        &lt;link rel="stylesheet" href="estilos.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;

        &lt;div class="contenedor-grid"&gt;
            &lt;div class="elemento-grid"&gt;Elemento 1&lt;/div&gt;
            &lt;div class="elemento-grid"&gt;Elemento 2&lt;/div&gt;
            &lt;div class="elemento-grid"&gt;Elemento 3&lt;/div&gt;
        &lt;/div&gt;

        &lt;/body&gt;
        &lt;/html&gt;

        <strong>estilos.css</strong>  

        .contenedor-grid { 
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            justify-items: center;
            align-items: center;
            background-color: #fff;
            padding: 20px;
        }
        
        .elemento-grid {
            background-color: #fd9dc9;
            color: rgb(0, 0, 0);
            text-align: center;
            padding: 20px;
            border-radius: 4px;
        }
        </pre>

        <div class="contenedor-grid">
            <div class="elemento-grid">Elemento 1</div>
            <div class="elemento-grid">Elemento 2</div>
            <div class="elemento-grid">Elemento 3</div>
        </div>

    </section>

    <section>
        <h2>Ventajas y Desventajas de las Nomenclaturas CSS</h2>

        <table border="1">
            <thead>
                <tr>
                    <th>Nomenclatura</th>
                    <th>Definición</th>
                    <th>Ventajas</th>
                    <th>Desventajas</th>
                    <th>Ejemplo</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>BEM (Block Element Modifier)</td>
                    <td>Una metodología de nombrado de clases CSS que divide las clases en bloques, elementos y modificadores.</td>
                    <td>
                        <ul>
                            <li>Facilita la escalabilidad y mantenimiento del código.</li>
                            <li>Evita conflictos de nombres en CSS.</li>
                            <li>Mejora la organización y claridad en proyectos grandes.</li>
                            <li>Promueve la reutilización de clases y facilita la comprensión por parte de otros desarrolladores.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Puede generar nombres de clases largas y difíciles de manejar.</li>
                            <li>Requiere disciplina y planificación rigurosa para evitar la duplicación de clases.</li>
                            <li>Puede volverse tedioso en proyectos pequeños.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.button {}</code> <br>
                        <code>.button__icon {}</code> <br>
                        <code>.button--large {}</code>
                    </td>
                </tr>
                <tr>
                    <td>CSS Semántico</td>
                    <td>Uso de nombres de clases que describen el propósito del contenido más que su estilo visual.</td>
                    <td>
                        <ul>
                            <li>Mejora la accesibilidad y el SEO (Search Engine Optimization) al utilizar etiquetas HTML significativas.</li>
                            <li>Facilita la comprensión del código por parte de otros desarrolladores.</li>
                            <li>Ayuda en la creación de una estructura lógica y organizada.</li>
                            <li>Aumenta la compatibilidad con lectores de pantalla.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Puede generar mayor complejidad si no se organiza bien.</li>
                            <li>Necesita una mayor planificación al comenzar el proyecto.</li>
                            <li>La sobrecarga de elementos semánticos puede resultar innecesaria.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.header {}</code><br>
                        <code>.article {}</code><br>
                        <code>.footer {}</code>
                    </td>
                </tr>
                <tr>
                    <td>CSS atómico</td>
                    <td>Crear clases pequeñas que representan una propiedad o conjunto de propiedades CSS y luego combinarlas.</td>
                    <td>
                        <ul>
                            <li>Proporciona clases pequeñas y reutilizables.</li>
                            <li>Permite una mayor flexibilidad al combinar clases.</li>
                            <li>Facilita la creación de diseños rápidos sin necesidad de escribir mucho CSS.</li>
                            <li>Permite optimizar el rendimiento al cargar solo las clases necesarias.</li>
                            <li>Facilita la personalización de componentes.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Aumenta la complejidad en el marcado HTML debido a la gran cantidad de clases.</li>
                            <li>Puede generar un código de CSS más difícil de leer.</li>
                            <li>Necesita una estructura bien definida para evitar confusión.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.bg-blue {}</code><br>
                        <code>.p-10 {}</code><br>
                        <code>.m-5 {}</code>
                    </td>
                </tr>
                <tr>
                    <td>Utility-first CSS</td>
                    <td>Uso de clases predefinidas para aplicar estilos rápidos y concisos directamente en el HTML. Derivada de CSS atómico.</td>
                    <td>
                        <ul>
                            <li>Fomenta la reutilización de clases de utilidad.</li>
                            <li>Evita la creación de CSS personalizado innecesario.</li>
                            <li>Permite un desarrollo rápido y eficiente.</li>
                            <li>Facilita el mantenimiento y la modificación del diseño sin tocar los estilos globales.</li>
                            <li>La personalización de la apariencia es sencilla mediante la combinación de clases.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Puede resultar en HTML menos limpio y más difícil de leer.</li>
                            <li>Requiere el uso de muchas clases, lo que puede hacer que el código sea más difícil de mantener.</li>
                            <li>La falta de organización puede generar redundancia en el CSS.</li>
                        </ul>
                    </td>
                    <td>
                        <code>&lt;div class="bg-blue p-5 m-5 text-white"&gt;Content&lt;/div&gt;</code>
                    </td>
                </tr>
                <tr>
                    <td>SMACSS (Scalable Modular Architecture for CSS)</td>
                    <td>Metodología que organiza el CSS en categorías modulares, como base, layout, módulos, estado y tema.</td>
                    <td>
                        <ul>
                            <li>Mejora la organización del código al dividirlo en categorías.</li>
                            <li>Facilita la mantenibilidad en proyectos grandes.</li>
                            <li>Permite un enfoque flexible, adaptándose a proyectos de cualquier tamaño.</li>
                            <li>Evita la duplicación de código, promoviendo la reutilización.</li>
                            <li>Proporciona un enfoque más modular para la organización del CSS.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Requiere un entendimiento profundo de la arquitectura para evitar caos.</li>
                            <li>Puede volverse difícil de mantener si no se aplica correctamente.</li>
                            <li>La estructura modular puede resultar más compleja de organizar en proyectos pequeños.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.btn {}</code><br>
                        <code>.btn-primary {}</code><br>
                        <code>.layout-header {}</code>
                    </td>
                </tr>
                <tr>
                    <td>OOCSS (Object-Oriented CSS)</td>
                    <td>Enfoque que trata a los elementos como "objetos", separando la estructura y el diseño.</td>
                    <td>
                        <ul>
                            <li>Favorece la reutilización y modularidad de los estilos.</li>
                            <li>Facilita la creación de componentes flexibles.</li>
                            <li>Permite la implementación de estilos consistentes en toda la aplicación.</li>
                            <li>Aumenta la coherencia de los componentes al desacoplar el estilo de la estructura.</li>
                            <li>Favorece la creación de interfaces de usuario más limpias y fáciles de modificar.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Requiere un buen conocimiento de la arquitectura de objetos.</li>
                            <li>Puede generar clases adicionales que sobrecargan el HTML.</li>
                            <li>Puede resultar más complejo de implementar al principio en proyectos grandes.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.media-object {}</code><br>
                        <code>.media-object img {}</code><br>
                        <code>.media-object-text {}</code>
                    </td>
                </tr>
                <tr>
                    <td>SUIT CSS</td>
                    <td>Metodología basada en la creación de componentes reutilizables con nombres de clases explícitos.</td>
                    <td>
                        <ul>
                            <li>Fomenta la creación de componentes modulares y reutilizables.</li>
                            <li>Mantiene un estilo consistente en aplicaciones grandes.</li>
                            <li>Permite una mayor facilidad de mantenimiento a largo plazo.</li>
                            <li>Ayuda en la creación de una arquitectura escalable.</li>
                            <li>Favorece la creación de componentes sin afectar el estilo global.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Requiere un entendimiento preciso de la nomenclatura.</li>
                            <li>Puede volverse difícil de aplicar si no se organiza correctamente.</li>
                            <li>La implementación de la arquitectura modular puede ser compleja en proyectos grandes.</li>
                        </ul>
                    </td>
                    <td>
                        <code>.Button {}</code><br>
                        <code>.Button--primary {}</code><br>
                        <code>.Button__icon {}</code>
                    </td>
                </tr>
            </tbody>
        </table>
    </section>


    <footer>
        <h2>Referencias bibliográficas</h2>
        <ul>
            <li>MDN Web Docs. (s.f). <i>Basic concepts of grid layout.</i> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout</a></li>
            <li>MDN Web Docs. (s.f). <i>Basic concepts of flexbox.</i> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox</a></li>
            <li>ManzDev. (s.f.). <i>Metodologías CSS.</i> <a href="https://lenguajecss.com/css/calidad-de-codigo/metodologias-css/" target="_blank">https://lenguajecss.com/css/calidad-de-codigo/metodologias-css/</a></li>
            <li>Agu, H. (2024). <i>Understanding CSS naming conventions: BEM, OOCSS, SUIT CSS, and SMACSS.</i> <a href="https://www.frontendmentor.io/articles/understanding-css-naming-conventions-bem-oocss-smacss-and-suit-css-V6ZZUYs1xz" target="_blank">https://www.frontendmentor.io/articles/understanding-css-naming-conventions-bem-oocss-smacss-and-suit-css-V6ZZUYs1xz</a></li>
            <li>Rodríguez, J. A. (2022). <i>BEM: La mejor forma de organizar tus clases en CSS.</i> <a href="https://baetica.com/bem-organizar-tclases-css/" target="_blank">https://baetica.com/bem-organizar-tclases-css/</a></li>
            <li>Arsenault, C. (2019). <i>OOCSS - The Future of Writing CSS.</i> <a href="https://www.keycdn.com/blog/oocss" target="_blank">https://www.keycdn.com/blog/oocss</a></li>
        </ul>
    </footer>

</body>
</html>